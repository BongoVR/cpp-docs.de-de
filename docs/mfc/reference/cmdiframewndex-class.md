---
title: CMDIFrameWndEx Class | Microsoft-Dokumentation
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-cpp
ms.tgt_pltfrm: 
ms.topic: reference
f1_keywords:
- CMDIFrameWndEx
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ActiveItemRecalcLayout
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::AddPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::AdjustClientArea
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::AdjustDockingLayout
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::AreMDITabs
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::CanCovertControlBarToMDIChild
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ControlBarToTabbedDocument
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::CreateDocumentWindow
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::CreateNewWindow
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::DockPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::DockPaneLeftOf
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableAutoHidePanes
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableDocking
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableFullScreenMainMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableFullScreenMode
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableLoadDockState
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableMDITabbedGroups
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableMDITabs
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableMDITabsLastActiveActivation
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnablePaneMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::EnableWindowsDialog
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetActivePopup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetDefaultResId
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetMDITabGroups
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetMDITabs
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetMDITabsContextMenuAllowedItems
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetMenuBar
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetRibbonBar
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetTearOffBars
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::GetToolbarButtonToolTipText
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::InsertPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsFullScreen
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsMDITabbedGroup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsMemberOfMDITabGroup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsMenuBarAvailable
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsPointNearDockSite
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::IsPrintPreview
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::LoadFrame
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::LoadMDIState
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::MDITabMoveToNextGroup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::MDITabNewGroup
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::NegotiateBorderSpace
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnCloseDockingPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnCloseMiniFrame
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnClosePopupMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnCmdMsg
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnDrawMenuImage
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnDrawMenuLogo
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnEraseMDIClientBackground
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnMenuButtonToolHitTest
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnMoveMiniFrame
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnSetPreviewMode
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnShowCustomizePane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnShowMDITabContextMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnShowPanes
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnShowPopupMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnSizeMDIClient
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnTearOffMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::OnUpdateFrameMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::PaneFromPoint
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::RecalcLayout
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::RemovePaneFromDockManager
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::SaveMDIState
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::SetPrintPreviewFrame
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::SetupToolbarMenu
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ShowFullScreen
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ShowPane
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::ShowWindowsDialog
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::TabbedDocumentToControlBar
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::UpdateCaption
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::UpdateMDITabbedBarsIcons
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::WinHelp
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::m_bCanCovertControlBarToMDIChild
- AFXMDIFRAMEWNDEX/CMDIFrameWndEx::m_bDisableSetRedraw
dev_langs:
- C++
helpviewer_keywords:
- CMDIFrameWndEx class
ms.assetid: dbcafcb3-9a7a-4f11-9dfe-ba57565c81d0
caps.latest.revision: 42
author: mikeblome
ms.author: mblome
manager: ghogen
translation.priority.ht:
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- ru-ru
- zh-cn
- zh-tw
translation.priority.mt:
- cs-cz
- pl-pl
- pt-br
- tr-tr
translationtype: Machine Translation
ms.sourcegitcommit: 0e0c08ddc57d437c51872b5186ae3fc983bb0199
ms.openlocfilehash: b9946f59b9ed789604ac6a02d2148188831bae56
ms.lasthandoff: 02/24/2017

---
# <a name="cmdiframewndex-class"></a>CMDIFrameWndEx-Klasse
Erweitert die Funktionalität von [CMDIFrameWnd](../../mfc/reference/cframewnd-class.md), eines Rahmenfensters Windows Interface (MDI, Multiple Document).  
  
## <a name="syntax"></a>Syntax  
  
```  
class CMDIFrameWndEx : public CMDIFrameWnd  
```  
  
## <a name="members"></a>Mitglieder  
  
### <a name="public-methods"></a>Öffentliche Methoden  
  
|Name|Beschreibung|  
|----------|-----------------|  
|[CMDIFrameWndEx::ActiveItemRecalcLayout](#activeitemrecalclayout)|Berechnet das Layout der aktiven Element.|  
|`CMDIFrameWndEx::AddDockSite`|Diese Methode wird nicht verwendet.|  
|[CMDIFrameWndEx::AddPane](#addpane)|Registriert einen Bereich mit dem docking-Manager.|  
|[CMDIFrameWndEx::AdjustClientArea](#adjustclientarea)|Reduziert den Clientbereich, um einen Rahmen zu ermöglichen.|  
|[CMDIFrameWndEx::AdjustDockingLayout](#adjustdockinglayout)|Berechnet das Layout der alle angedockten Fenster an.|  
|[CMDIFrameWndEx::AreMDITabs](#aremditabs)|Bestimmt, ob die MDI-Registerkarten-Funktion oder das Feature im Registerkartenformat MDI-Gruppen aktiviert ist.|  
|[CMDIFrameWndEx::CanCovertControlBarToMDIChild](#cancovertcontrolbartomdichild)|Aufgerufen, um festzustellen, ob das Rahmenfenster andockbare Bereiche in Dokumente im Registerformat konvertieren kann.|  
|[CMDIFrameWndEx::ControlBarToTabbedDocument](#controlbartotabbeddocument)|Konvertiert die angegebene andockbaren Bereich, ein Dokument im Registerkartenformat.|  
|[CMDIFrameWndEx::CreateDocumentWindow](#createdocumentwindow)|Erstellt eine untergeordnete Dokument.|  
|[CMDIFrameWndEx::CreateNewWindow](#createnewwindow)|Aufgerufen, um ein neues Fenster zu erstellen.|  
|`CMDIFrameWndEx::CreateObject`|Wird vom Framework verwendet, um eine dynamische Instanz dieses Klassentyps zu erstellen.|  
|[CMDIFrameWndEx::DockPane](#dockpane)|Das Rahmenfenster im angegebenen Bereich angedockt.|  
|[CMDIFrameWndEx::DockPaneLeftOf](#dockpaneleftof)|Dockt einen Bereich auf der linken Seite eines anderen Bereichs an.|  
|[CMDIFrameWndEx::EnableAutoHidePanes](#enableautohidepanes)|Ermöglicht das automatische Ausblenden Modus für Bereiche, wenn diese am angegebenen Seiten des Hauptrahmenfenster angedockt sind.|  
|[CMDIFrameWndEx::EnableDocking](#enabledocking)|Ermöglicht das Andocken der Bereiche, die MDI-Rahmenfenster angehören.|  
|[CMDIFrameWndEx::EnableFullScreenMainMenu](#enablefullscreenmainmenu)|Anzeigen oder ausblenden im Hauptmenü in den Vollbildmodus.|  
|[CMDIFrameWndEx::EnableFullScreenMode](#enablefullscreenmode)|Ermöglicht den Vollbildmodus für das Rahmenfenster.|  
|[CMDIFrameWndEx::EnableLoadDockState](#enableloaddockstate)|Aktiviert oder deaktiviert das Laden der Andockstatus.|  
|[CMDIFrameWndEx::EnableMDITabbedGroups](#enablemditabbedgroups)|Aktiviert oder deaktiviert das Feature im Registerkartenformat MDI-Gruppen.|  
|[CMDIFrameWndEx::EnableMDITabs](#enablemditabs)|Aktiviert oder deaktiviert die Funktion MDI-Registerkarten. Wenn diese Option aktiviert ist, zeigt das Rahmenfenster eine Registerkarte für jedes untergeordnete MDI-Fenster.|  
|[CMDIFrameWndEx::EnableMDITabsLastActiveActivation](#enablemditabslastactiveactivation)|Gibt an, ob die letzte aktive Registerkarte aktiviert werden soll, wenn der Benutzer die aktuelle Registerkarte geschlossen wird.|  
|[CMDIFrameWndEx::EnablePaneMenu](#enablepanemenu)|Aktiviert oder deaktiviert die automatische Erstellung und Verwaltung von Popup im Menü, das eine Liste von Bereichen der Anwendung angezeigt.  .|  
|[CMDIFrameWndEx::EnableWindowsDialog](#enablewindowsdialog)|Fügt ein Menüelement, dessen Befehls-ID Ruft, eine [CMFCWindowsManagerDialog](../../mfc/reference/cmfcwindowsmanagerdialog-class.md) das Dialogfeld.|  
|[CMDIFrameWndEx::GetActivePopup](#getactivepopup)|Gibt einen Zeiger auf das aktuell angezeigte Popupmenü zurück.|  
|[CMDIFrameWndEx::GetPane](#getpane)|Gibt einen Zeiger auf den Bereich, der die angegebene Steuerelement-ID verfügt.|  
|[CMDIFrameWndEx::GetDefaultResId](#getdefaultresid)|Gibt die ID der freigegebenen Ressourcen des MDI-Rahmenfenster.|  
|[CMDIFrameWndEx::GetMDITabGroups](#getmditabgroups)|Gibt eine Liste der MDI-Windows im Registerkartenformat zurück.|  
|[CMDIFrameWndEx::GetMDITabs](#getmditabs)|Gibt einen Verweis auf die unterstrichenen Fenster im Registerkartenformat zurück.|  
|[CMDIFrameWndEx::GetMDITabsContextMenuAllowedItems](#getmditabscontextmenualloweditems)|Gibt eine Kombination von Flags, die bestimmt, welche Kontextmenüelemente gültig sind, wenn das Feature im Registerkartenformat MDI-Gruppen aktiviert ist.|  
|[CMDIFrameWndEx::GetMenuBar](#getmenubar)|Gibt einen Zeiger auf ein Menü Bar-Objekt an das Rahmenfenster angefügt.|  
|[CMDIFrameWndEx::GetRibbonBar](#getribbonbar)|Ruft die Menüband-Steuerelement für den Rahmen.|  
|[CMDIFrameWndEx::GetTearOffBars](#gettearoffbars)|Gibt eine Liste von [CPane](../../mfc/reference/cpane-class.md)-abgeleitete Objekte, die in einem abtrennbare Zustand befinden.|  
|`CMDIFrameWndEx::GetThisClass`|Aufgerufen, um einen Zeiger auf die [CRuntimeClass](../../mfc/reference/cruntimeclass-structure.md) -Objekt, das Klassentyp zugeordnet ist.|  
|[CMDIFrameWndEx::GetToolbarButtonToolTipText](#gettoolbarbuttontooltiptext)|Vom Framework aufgerufen, wenn die Anwendung die QuickInfo für eine Symbolleisten-Schaltfläche angezeigt wird.|  
|[CMDIFrameWndEx::InsertPane](#insertpane)|Registriert den angegebenen Bereich der docking-Manager.|  
|[CMDIFrameWndEx::IsFullScreen](#isfullscreen)|Bestimmt, ob das Rahmenfenster in den Vollbildmodus.|  
|[CMDIFrameWndEx::IsMDITabbedGroup](#ismditabbedgroup)|Bestimmt, ob das Feature im Registerkartenformat MDI-Gruppen aktiviert ist.|  
|[CMDIFrameWndEx::IsMemberOfMDITabGroup](#ismemberofmditabgroup)|Bestimmt, ob das angegebene Fenster im Registerkartenformat in der Liste von Windows, die im MDI-Gruppen im Registerkartenformat sind.|  
|[CMDIFrameWndEx::IsMenuBarAvailable](#ismenubaravailable)|Bestimmt, ob das Rahmenfenster Menüleiste.|  
|[CMDIFrameWndEx::IsPointNearDockSite](#ispointneardocksite)|Bestimmt, ob es sich bei ein angegebenen Punkt in der Nähe der Dock-Website befindet.|  
|[CMDIFrameWndEx::IsPrintPreview](#isprintpreview)|Bestimmt, ob das Rahmenfenster in den Seitenansicht-Modus.|  
|[CMDIFrameWndEx::LoadFrame](#loadframe)|Erstellt ein Rahmenfenster von Ressourceninformationen. (Überschreibt `CMDIFrameWnd::LoadFrame`.)|  
|[CMDIFrameWndEx::LoadMDIState](#loadmdistate)|Lädt das angegebene Layout im Registerkartenformat MDI-Gruppen und die Liste der zuvor geöffneten Dokumente.|  
|[CMDIFrameWndEx::MDITabMoveToNextGroup](#mditabmovetonextgroup)|Verschiebt die aktive Registerkarte aus der aktuell aktiven Fenster im Registerkartenformat an den nächsten oder vorherigen Registerkartengruppe.|  
|[CMDIFrameWndEx::MDITabNewGroup](#mditabnewgroup)|Erstellt eine neue Registerkarte Gruppe, die ein einzelnes Fenster.|  
|[CMDIFrameWndEx::NegotiateBorderSpace](#negotiateborderspace)|Verhandelt Rahmen Speicherplatz in einem Rahmenfenster während OLE-Ort-Aktivierung.|  
|[CMDIFrameWndEx::OnCloseDockingPane](#onclosedockingpane)|Vom Framework aufgerufen, wenn der Benutzer klickt auf die **schließen** auf einen andockbaren Bereich auf die Schaltfläche.|  
|[CMDIFrameWndEx::OnCloseMiniFrame](#oncloseminiframe)|Vom Framework aufgerufen, wenn der Benutzer klickt auf die **schließen** Schaltfläche auf einem schwebenden Mini-Rahmenfenster.|  
|[CMDIFrameWndEx::OnClosePopupMenu](#onclosepopupmenu)|Vom Framework aufgerufen, wenn eine aktive Popupmenü verarbeitet eine `WM_DESTROY` Nachricht.|  
|[CMDIFrameWndEx::OnCmdMsg](#oncmdmsg)|Vom Framework aufgerufen, weiterleiten und verteilen Befehl Nachrichten und Befehlsobjekte Benutzeroberfläche aktualisieren.|  
|[CMDIFrameWndEx::OnDrawMenuImage](#ondrawmenuimage)|Wird vom Framework aufgerufen, wenn das einem Menüelement zugeordnete Bild gezeichnet wird.|  
|[CMDIFrameWndEx::OnDrawMenuLogo](#ondrawmenulogo)|Aufgerufen, wenn ein [CMFCPopupMenu](../../mfc/reference/cmfcpopupmenu-class.md)Prozesse eine `WM_PAINT` Nachricht.|  
|[CMDIFrameWndEx::OnEraseMDIClientBackground](#onerasemdiclientbackground)|Vom Framework aufgerufen, wenn der frame MDI-Fenster Prozesse eine `WM_ERASEBKGND` Nachricht.|  
|[CMDIFrameWndEx::OnMenuButtonToolHitTest](#onmenubuttontoolhittest)|Vom Framework aufgerufen wird bei einer [CMFCToolBarButton](../../mfc/reference/cmfctoolbarbutton-class.md)-Objekt Prozesse eine `WM_NCHITTEST` Nachricht.|  
|[CMDIFrameWndEx::OnMoveMiniFrame](#onmoveminiframe)|Aufgerufen, um ein Minirahmenfenster zu verschieben.|  
|[CMDIFrameWndEx::OnSetPreviewMode](#onsetpreviewmode)|Legt die Anwendung Hauptframe Fenster Seitenansicht Modus fest. (Überschreibt [CFrameWnd::OnSetPreviewMode](../../mfc/reference/cframewnd-class.md#onsetpreviewmode).)|  
|[CMDIFrameWndEx::OnShowCustomizePane](#onshowcustomizepane)|Wird vom Framework aufgerufen, wenn ein Bereich Quick anpassen aktiviert wird.|  
|[CMDIFrameWndEx::OnShowMDITabContextMenu](#onshowmditabcontextmenu)|Wird vom Framework aufgerufen, wenn ein Kontextmenü auf eine der Registerkarten angezeigt werden sollen. (Gültig für MDI-Gruppen nur im Registerkartenformat.)|  
|[CMDIFrameWndEx::OnShowPanes](#onshowpanes)|Vom Framework aufgerufen wird, anzeigen oder Ausblenden von Bereichen.|  
|[CMDIFrameWndEx::OnShowPopupMenu](#onshowpopupmenu)|Wird vom Framework aufgerufen, wenn ein Popupmenü aktiviert wird.|  
|[CMDIFrameWndEx::OnSizeMDIClient](#onsizemdiclient)|Vom Framework aufgerufen, wenn die Größe des MDI-Clientfenster geändert wird.|  
|[CMDIFrameWndEx::OnTearOffMenu](#ontearoffmenu)|Wird vom Framework aufgerufen, wenn ein Menü mit abtrennbarer Leiste aktiviert wird.|  
|[CMDIFrameWndEx::OnUpdateFrameMenu](#onupdateframemenu)|Vom Framework aufgerufen wird, klicken Sie im Frame zu aktualisieren. (Überschreibt `CMDIFrameWnd::OnUpdateFrameMenu`.)|  
|[CMDIFrameWndEx::PaneFromPoint](#panefrompoint)|Gibt die andockbaren Bereich, der den angegebenen Punkt enthält.|  
|`CMDIFrameWndEx::PreTranslateMessage`|Von der Klasse verwendet [CWinApp](../../mfc/reference/cwinapp-class.md) auf fenstermeldungen zu übersetzen, bevor sie an verteilt sind die [TranslateMessage](http://msdn.microsoft.com/library/windows/desktop/ms644955) und [DispatchMessage](http://msdn.microsoft.com/library/windows/desktop/ms644934) Windows-Funktionen.  (Überschreibt `CMDIFrameWnd::PreTranslateMessage`.)|  
|[CMDIFrameWndEx::RecalcLayout](#recalclayout)|Aufgerufen, um das Layout des Rahmenfensters neu zu berechnen. (Überschreibt [CFrameWnd::RecalcLayout](../../mfc/reference/cframewnd-class.md#recalclayout).)|  
|[CMDIFrameWndEx::RemovePaneFromDockManager](#removepanefromdockmanager)|Hebt die Registrierung eines Bereichs, und entfernt sie aus der Dockingstation-Manager.|  
|[CMDIFrameWndEx::SaveMDIState](#savemdistate)|Speichert das aktuelle Layout im Registerkartenformat MDI-Gruppen und die Liste der zuvor geöffneten Dokumente.|  
|[CMDIFrameWndEx::SetPrintPreviewFrame](#setprintpreviewframe)|Legt das Rahmenfenster Seitenansicht.|  
|[CMDIFrameWndEx::SetupToolbarMenu](#setuptoolbarmenu)|Ändert ein Symbolleistenobjekt durch die Suche nach Dummy-Elementen und durch das anschließende Ersetzen dieser Dummy-Elemente durch die angegebenen benutzerdefinierten Elemente.|  
|[CMDIFrameWndEx::ShowFullScreen](#showfullscreen)|Wechselt den Hauptframe vom normalen Modus auf den Vollbildmodus.|  
|[CMDIFrameWndEx::ShowPane](#showpane)|Anzeigen oder ausblenden im angegebenen Bereich.|  
|[CMDIFrameWndEx::ShowWindowsDialog](#showwindowsdialog)|Erstellt eine [CMFCWindowsManagerDialog](../../mfc/reference/cmfcwindowsmanagerdialog-class.md) Feld und öffnet sie.|  
|[CMDIFrameWndEx::TabbedDocumentToControlBar](#tabbeddocumenttocontrolbar)|Konvertiert das angegebene Dokument im Registerkartenformat an einen andockbaren Bereich.|  
|[CMDIFrameWndEx::UpdateCaption](#updatecaption)|Aufgerufen, um die Beschriftung des Fensters Frame zu aktualisieren.|  
|[CMDIFrameWndEx::UpdateMDITabbedBarsIcons](#updatemditabbedbarsicons)|Wird das Symbol für jede MDI im Registerformat.|  
|[CMDIFrameWndEx::WinHelp](#winhelp)|Wird vom Framework aufgerufen, um die WinHelp-Anwendung oder die Kontexthilfe zu initiieren. (Überschreibt [CWnd::WinHelp](../../mfc/reference/cwnd-class.md#winhelp).)|  
  
### <a name="data-members"></a>Datenmember  
  
|Name|Beschreibung|  
|----------|-----------------|  
|[CMDIFrameWndEx::m_bCanCovertControlBarToMDIChild](#m_bcancovertcontrolbartomdichild)|Bestimmt, ob untergeordnete MDI-Fenster andockbare Bereiche konvertiert werden können.|  
|[CMDIFrameWndEx::m_bDisableSetRedraw](#m_bdisablesetredraw)|Aktiviert oder deaktiviert die Neuzeichnen Optimierung für untergeordnete MDI-Fenster.|  
  
## <a name="remarks"></a>Hinweise  
 Um erweiterte Funktionen in der MDI-Anwendung nutzen zu können, leiten Sie die MDI-Rahmenfenster (Klasse) der Anwendung von `CMDIFrameWndEx` anstelle von `CMDIFrameWnd`.  
  
## <a name="example"></a>Beispiel  
 Im folgende Beispiel wird eine Klasse von abgeleitet `CMDIFrameWndEx`. Dieser Codeausschnitt stammt aus der [DrawClient-Beispiel: MFC Ribbon-Based OLE-Objekt Zeichenanwendung](../../visual-cpp-samples.md).  
  
 [!code-cpp[NVC_MFC_DrawClient&#1;](../../mfc/reference/codesnippet/cpp/cmdiframewndex-class_1.h)]  
  
## <a name="inheritance-hierarchy"></a>Vererbungshierarchie  
 [Von CObject](../../mfc/reference/cobject-class.md)  
  
 [CCmdTarget](../../mfc/reference/ccmdtarget-class.md)  
  
 [CWnd](../../mfc/reference/cwnd-class.md)  
  
 [CFrameWnd](../../mfc/reference/cframewnd-class.md)  
  
 [CMDIFrameWnd](../../mfc/reference/cmdiframewnd-class.md)  
  
 [CMDIFrameWndEx](../../mfc/reference/cmdiframewndex-class.md)  
  
## <a name="requirements"></a>Anforderungen  
 **Header:** afxMDIFrameWndEx.h  
  
##  <a name="activeitemrecalclayout"></a>CMDIFrameWndEx::ActiveItemRecalcLayout  
 Berechnet das Layout der aktiven Element.  
  
```  
void ActiveItemRecalcLayout();
```  
  
##  <a name="addpane"></a>CMDIFrameWndEx::AddPane  
 Registriert einen Bereich mit dem docking-Manager.  
  
```  
BOOL AddPane(
    CBasePane* pControlBar,  
    BOOL bTail=TRUE);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `pControlBar`  
 Ein Zeiger auf den Bereich zu registrieren.  
  
 [in] `bTail`  
 Gibt an, ob dieser Bereich am Ende der Liste hinzugefügt werden soll.  
  
### <a name="return-value"></a>Rückgabewert  
 Gibt einen Wert ungleich NULL zurück, wenn Bereich erfolgreich registriert wurde. Gibt 0 zurück, wenn der Bereich bereits docking-Manager registriert ist.  
  
### <a name="remarks"></a>Hinweise  
 Jeder Bereich muss registriert sein, mit der [CDockingManager-Klasse](../../mfc/reference/cdockingmanager-class.md) , bevor er einen andockbaren Layout teilnehmen kann. Verwenden Sie diese Methode auf den docking benachrichtigen, dass Sie ein bestimmtes Fenster andocken möchten. Nach diesem Bereich registriert ist, richtet der Dockingstation Manager basierend auf seiner Einstellung für die Ausrichtung und Position in der Liste der Bereiche, die von der Dockingstation-Manager verwaltet wird.  
  
##  <a name="adjustclientarea"></a>CMDIFrameWndEx::AdjustClientArea  
 Reduziert den Clientbereich, um einen Rahmen zu ermöglichen.  
  
```  
virtual void AdjustClientArea();
```  
  
##  <a name="adjustdockinglayout"></a>CMDIFrameWndEx::AdjustDockingLayout  
 Berechnet das Layout der alle angedockten Fenster an.  
  
```  
virtual void AdjustDockingLayout(HDWP hdwp=NULL);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `hdwp`  
 Identifiziert die Fensterposition mehrere-Struktur. Sie können diesen Wert abrufen, durch Aufrufen von `BeginDeferWindowPos`.  
  
### <a name="remarks"></a>Hinweise  
 Rufen Sie diese Memberfunktion, um das Layout für alle Bereiche, die an das Rahmenfenster angedockt neu zu berechnen.  
  
##  <a name="aremditabs"></a>CMDIFrameWndEx::AreMDITabs  
 Bestimmt, ob die MDI-Registerkarten-Funktion oder die MDI-Gruppen im Registerkartenformat-Funktion aktiviert ist.  
  
```  
BOOL AreMDITabs(int* pnMDITabsType=NULL) const;  
```  
  
### <a name="parameters"></a>Parameter  
 [out] `pnMDITabsType`  
 Ein Zeiger auf eine ganzzahlige Variable, die angibt, welche Funktionen aktiviert sind:  
  
-   0: alle Funktionen werden deaktiviert.  
  
-   1: MDI-Registerkarten aktiviert ist.  
  
-   2: im Registerkartenformat MDI-Gruppen ist aktiviert.  
  
### <a name="return-value"></a>Rückgabewert  
 `Returns TRUE`Wenn der MDI-Registerkarten oder MDI-Gruppen im Registerkartenformat aktiviert ist.  
  
 `Returns FALSE`Wenn keine der oben genannten Features aktiviert ist.  
  
### <a name="remarks"></a>Hinweise  
 Verwenden Sie diese Funktion, um festzustellen, ob die MDI-Registerkarten oder MDI-Gruppen im Registerkartenformat aktiviert ist für das Rahmenfenster. Verwendung [CMDIFrameWndEx::EnableMDITabs](#enablemditabs) aktivieren oder deaktivieren Sie die MDI-Registerkarten.  
  
 Verwendung [CMDIFrameWndEx::EnableMDITabbedGroups](#enablemditabbedgroups) aktivieren oder deaktivieren Sie die MDI-Gruppen im Registerkartenformat.  
  
##  <a name="cancovertcontrolbartomdichild"></a>CMDIFrameWndEx::CanCovertControlBarToMDIChild  
 Aufgerufen, um festzustellen, ob das Rahmenfenster andockbare Bereiche in Dokumente im Registerformat konvertieren kann  
  
```  
virtual BOOL CanCovertControlBarToMDIChild();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Gibt `TRUE` , wenn das Rahmenfenster andockbare Bereiche in Dokumenten im Registerformat angezeigt konvertieren; andernfalls `FALSE`.  
  
### <a name="remarks"></a>Hinweise  
 Diese Methode in einer abgeleiteten Klasse überschreiben und zurückgeben `TRUE` zum Aktivieren der Konvertierung von Bereichen Dokumente im Registerkartenformat andocken. Sie können alternativ festlegen [CMDIFrameWndEx::m_bCanCovertControlBarToMDIChild](#m_bcancovertcontrolbartomdichild) auf `TRUE`.  
  
##  <a name="controlbartotabbeddocument"></a>CMDIFrameWndEx::ControlBarToTabbedDocument  
 Konvertiert die angegebene andockbaren Bereich, ein Dokument im Registerkartenformat.  
  
```  
virtual CMDIChildWndEx* ControlBarToTabbedDocument(CDockablePane* pBar);
```  
  
### <a name="parameters"></a>Parameter  
 `pBar`  
 Ein Zeiger auf die andockbaren konvertieren.  
  
### <a name="return-value"></a>Rückgabewert  
 Gibt einen Zeiger auf den neuen untergeordneten MDI-Fensters, der die andockbaren Bereich enthält.  
  
### <a name="remarks"></a>Hinweise  
 Diese Methode konvertiert einen andockbaren Bereich, um ein Dokument im Registerkartenformat. Wenn Sie diese Methode aufrufen, erstellt das Framework eine [CMDIChildWndEx-Klasse](../../mfc/reference/cmdichildwndex-class.md) Objekt andockbaren Bereich aus der Dockingstation Manager entfernt, und die neuen untergeordneten MDI-Fensters andockbaren Bereich hinzugefügt. Die untergeordneten MDI-Fensters ändert die Größe der andockbaren Bereich, um den gesamten Clientbereich abzudecken.  
  
##  <a name="createdocumentwindow"></a>CMDIFrameWndEx::CreateDocumentWindow  
 Erstellt eine untergeordnete Dokument.  
  
```  
virtual CMDIChildWndEx* CreateDocumentWindow(
    LPCTSTR lpcszDocName,  
    CObject* pObj);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `lpcszDocName`  
 Eine Textzeichenfolge, die eine Dokument-ID enthält. In der Regel ist es den vollständigen Pfad einer Datei Dokument.  
  
 [in] `pObj`  
 Ein Zeiger auf ein benutzerdefiniertes Objekt. Beispielsweise kann ein Entwickler den Erstellen einer anwendungsspezifischen Datenstruktur zur Beschreibung des Dokuments und darüber informiert, wie das Dokument beim Starten initialisiert werden soll.  
  
### <a name="return-value"></a>Rückgabewert  
 Ein Zeiger auf `CMDIChildWndEx`.  
  
### <a name="remarks"></a>Hinweise  
 Das Framework ruft diese Methode beim Laden der Liste der Dokumente, die zuvor in der Registrierung gespeichert.  
  
 Überschreiben Sie diese Methode, um Dokumente zu erstellen, wenn diese aus der Registrierung geladen werden.  
  
### <a name="example"></a>Beispiel  
 Das folgende Beispiel zeigt wie `CreateDocumentWindow` werden in der [VisualStudioDemo-Beispiel: MFC-Anwendung für Visual Studio](../../visual-cpp-samples.md).  
  
 In diesem Beispiel `g_strStartViewName` möglicherweise der Namen der ein "virtuelles Dokument" (z. B. "Startseite"), die nicht tatsächlich aus einer Datenträgerdatei geladen wird. Daher benötigen wir spezielle Verarbeitung aus, um diese Fälle zu behandeln.  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo&#13;](../../mfc/codesnippet/cpp/cmdiframewndex-class_2.cpp)]  
  
##  <a name="createnewwindow"></a>CMDIFrameWndEx::CreateNewWindow  
 Aufgerufen, um ein neues Fenster zu erstellen.  
  
```  
virtual CMDIChildWndEx* CreateNewWindow(
    LPCTSTR lpcszDocName,  
    CObject* pObj);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `lpcszDocName`  
 Der Dokumentname.  
  
 [in] `pObj`  
 Für zukünftige Verwendung reserviert.  
  
### <a name="return-value"></a>Rückgabewert  
 Ein Zeiger auf das neue Fenster.  
  
##  <a name="dockpane"></a>CMDIFrameWndEx::DockPane  
 Das Rahmenfenster im angegebenen Bereich angedockt.  
  
```  
void DockPane(
    CBasePane* pBar,  
    UINT nDockBarID=0,  
    LPCRECT lpRect=NULL);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `pBar`  
 Ein Zeiger auf den Bereich angedockt.  
  
 [in] `nDockBarID`  
 Gibt an, welche Seiten des Rahmenfensters angedockt.  
  
 [in] `lpRect`  
 Nicht verwendet.  
  
### <a name="remarks"></a>Hinweise  
 Diese Methode das angegebene Dockt den Bereich, um einer der Seiten des Rahmenfensters, die angegebenen [CBasePane::EnableDocking](../../mfc/reference/cbasepane-class.md#enabledocking) und [CMDIFrameWndEx::EnableDocking](#enabledocking) aufgerufen wurden.  
  
### <a name="example"></a>Beispiel  
 Im folgenden Beispiel wird die Verwendung der `DockPane`-Methode gezeigt. Dieser Codeausschnitt stammt aus der [VisualStudioDemo-Beispiel: MFC-Anwendung für Visual Studio](../../visual-cpp-samples.md).  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo&4;](../../mfc/codesnippet/cpp/cmdiframewndex-class_3.cpp)]  
  
##  <a name="dockpaneleftof"></a>CMDIFrameWndEx::DockPaneLeftOf  
 Dockt einen Bereich auf der linken Seite eines anderen Bereichs an.  
  
```  
BOOL DockPaneLeftOf(
    CPane* pBar,  
    CPane* pLeftOf);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `pBar`  
 Ein Zeiger auf die andockbaren Bereich.  
  
 [in] `pLeftOf`  
 Ein Zeiger auf den Bereich, der als Andocken Standort dient. .  
  
### <a name="return-value"></a>Rückgabewert  
 Gibt `TRUE` , wenn der Vorgang erfolgreich ist. Andernfalls wird `FALSE` zurückgegeben.  
  
### <a name="remarks"></a>Hinweise  
 Rufen Sie diese Methode, um mehrere Bereich Objekte in einer vordefinierten Reihenfolge andocken. Diese Methode wird im angegebenen Bereich angedockt `pBar` auf der linken Seite des angegebenen Bereichs `pLeftOf`.  
  
### <a name="example"></a>Beispiel  
 Das folgende Beispiel zeigt wie die `DockPaneLeftOf` -Methode verwendet wird, die [VisualStudioDemo-Beispiel: MFC-Anwendung für Visual Studio](../../visual-cpp-samples.md).  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo&5;](../../mfc/codesnippet/cpp/cmdiframewndex-class_4.cpp)]  
  
##  <a name="enableautohidepanes"></a>CMDIFrameWndEx::EnableAutoHidePanes  
 Ermöglicht das automatische Ausblenden Modus für Bereiche, wenn diese an den angegebenen Seiten des Hauptrahmenfenster angedockt sind.  
  
```  
BOOL EnableAutoHidePanes(DWORD dwDockStyle);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `dwDockStyle`  
 Gibt die Seiten für das Hauptrahmenfenster, das aktiviert werden sollen. Verwenden Sie eine oder mehrere der folgenden Flags.  
  
- `CBRS_ALIGN_LEFT`  
  
- `CBRS_ALIGN_RIGHT`  
  
- `CBRS_ALIGN_TOP`  
  
- `CBRS_ALIGN_BOTTOM`  
  
### <a name="return-value"></a>Rückgabewert  
 Rufen Sie diese Funktion, um automatisch im Hintergrund-Modus für Bereiche aktivieren, wenn diese an den angegebenen Seiten des Hauptrahmenfenster angedockt sind.  
  
### <a name="example"></a>Beispiel  
 Das folgende Beispiel zeigt wie die `EnableAutoHidePanes` -Methode verwendet wird, die [VisualStudioDemo-Beispiel: MFC-Anwendung für Visual Studio](../../visual-cpp-samples.md).  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo&6;](../../mfc/codesnippet/cpp/cmdiframewndex-class_5.cpp)]  
  
### <a name="remarks"></a>Hinweise  
  
##  <a name="enabledocking"></a>CMDIFrameWndEx::EnableDocking  
 Ermöglicht das Andocken der Bereiche, die MDI-Rahmenfenster angehören.  
  
```  
BOOL EnableDocking(DWORD dwDockStyle);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `dwDockStyle`  
 Gibt den andockstil, den Sie anwenden möchten.  
  
### <a name="return-value"></a>Rückgabewert  
  
### <a name="remarks"></a>Hinweise  
 Mit dieser Funktion können Sie aktivieren Sie das Andocken von Bereichen, die zu gehören die `CMDIFrameWndEx` Objekt.  
  
### <a name="example"></a>Beispiel  
 Das folgende Beispiel zeigt wie die `EnableDocking` -Methode verwendet wird, die [VisualStudioDemo-Beispiel: MFC-Anwendung für Visual Studio](../../visual-cpp-samples.md).  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo&#7;](../../mfc/codesnippet/cpp/cmdiframewndex-class_6.cpp)]  
  
##  <a name="enablefullscreenmainmenu"></a>CMDIFrameWndEx::EnableFullScreenMainMenu  
 Anzeigen oder ausblenden im Hauptmenü in den Vollbildmodus.  
  
```  
void EnableFullScreenMainMenu(BOOL bEnableMenu);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `bEnableMenu`  
 `TRUE`im Hauptmenü in den Vollbildmodus angezeigt oder `FALSE` um ihn auszublenden.  
  
### <a name="remarks"></a>Hinweise  
  
##  <a name="enablefullscreenmode"></a>CMDIFrameWndEx::EnableFullScreenMode  
 Ermöglicht den Vollbildmodus für das Rahmenfenster.  
  
```  
void EnableFullScreenMode(UINT uiFullScreenCmd);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `uiFullScreenCmd`  
 Die ID eines Befehls, der aktiviert oder deaktiviert den Vollbildmodus.  
  
### <a name="remarks"></a>Hinweise  
 Im Vollbildmodus alle andockbarer Steuerleisten, Symbolleisten und Menüs ausgeblendet, und die aktive Ansicht wird angepasst, um den Vollbildmodus zu belegen. Wenn Sie den Vollbildmodus aktivieren, müssen Sie eine Befehls-ID angeben, die aktiviert oder deaktiviert wird. Rufen Sie `EnableFullScreenMode` aus des Hauptframe `OnCreate` Funktion. Wenn ein Rahmenfenster in den Vollbildmodus wechselt wird, erstellt das Framework eine mit einer Schaltfläche mit der angegebenen Befehls-ID. Wenn Sie im Hauptmenü auf dem Bildschirm angezeigt werden sollen, rufen Sie [CMDIFrameWndEx::EnableFullScreenMainMenu](#enablefullscreenmainmenu).  
  
##  <a name="enableloaddockstate"></a>CMDIFrameWndEx::EnableLoadDockState  
 Aktiviert oder deaktiviert das Laden der Andockstatus.  
  
```  
void EnableLoadDockState(BOOL bEnable = TRUE);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `bEnable`  
 `TRUE`So aktivieren Sie das Laden der Andockstatus `FALSE` das Laden der Andockstatus deaktivieren.  
  
### <a name="remarks"></a>Hinweise  
  
##  <a name="enablemditabbedgroups"></a>CMDIFrameWndEx::EnableMDITabbedGroups  
 Aktiviert oder deaktiviert die MDI-Gruppen im Registerkartenformat-Funktion für das Rahmenfenster.  
  
```  
void EnableMDITabbedGroups(
    BOOL bEnable,  
    const CMDITabInfo& params);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `bEnable`  
 Wenn `TRUE`, die MDI-Gruppen im Registerkartenformat-Funktion aktiviert ist, wenn `FALSE`, die MDI-Gruppen im Registerkartenformat-Funktion ist deaktiviert.  
  
 [in] `params`  
 Gibt Parameter an, denen das Framework für untergeordnete Fenster gilt, die im MDI-Clientbereich erstellt werden.  
  
### <a name="remarks"></a>Hinweise  
 Verwenden Sie diese Methode zum Aktivieren oder deaktivieren Sie die MDI-Gruppen im Registerkartenformat. Dieses Feature ermöglicht MDI-Anwendung, der als Fenster im Registerkartenformat, die vertikal ausgerichtet sind oder horizontal innerhalb des MDI-Clientbereichs untergeordnete Fenster angezeigt. Gruppen von Fenstern im Registerformat werden durch Splitter getrennt. Die Benutzer kann Gruppen im Registerkartenformat durch Verwenden eines Splitters ändern.  
  
-   Der Benutzer kann:  
  
-   Ziehen Sie die einzelne Registerkarten zwischen Gruppen.  
  
-   Ziehen Sie die einzelne Registerkarten an den Rand des Fensters, um neue Gruppen zu erstellen.  
  
-   Verschieben von Registerkarten oder neue Gruppen erstellen, über ein Kontextmenü.  
  
-   Die Anwendung kann das aktuelle Layout des im Registerformat und die Liste der aktuell geöffneten Dokumente speichern.  
  
 Wenn Sie diese Methode mit Aufrufen `bEnable` festgelegt `FALSE`, `params` wird ignoriert.  
  
 Auch wenn im Registerkartenformat MDI-Gruppen bereits aktiviert ist, können Sie diese Methode erneut aus, um die Einstellungen für untergeordnete Fenster aufrufen. Rufen Sie die Methode mit `bEnable` festgelegt `TRUE` und ändern Sie die Mitglieder der `CMDITabInfo` -Objekt, das vom angegebenen der `params` Parameter.  
  
 Weitere Informationen zur Verwendung von MDI Gruppen im Registerkartenformat, finden Sie unter [MDI-Gruppen im Registerkartenformat](../../mfc/mdi-tabbed-groups.md).  
  
### <a name="example"></a>Beispiel  
 Das folgende Beispiel zeigt wie `EnableMDITabbedGroups` werden in der [VisualStudioDemo-Beispiel: MFC-Anwendung für Visual Studio](../../visual-cpp-samples.md).  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo&#8;](../../mfc/codesnippet/cpp/cmdiframewndex-class_7.cpp)]  
  
##  <a name="enablemditabs"></a>CMDIFrameWndEx::EnableMDITabs  
 Aktiviert oder deaktiviert die Funktion MDI-Registerkarten für MDI-Rahmenfenster. Wenn diese Option aktiviert ist, zeigt das Rahmenfenster eine Registerkarte für jedes untergeordnete MDI-Fenster.  
  
```  
void EnableMDITabs(
    BOOL bEnable=TRUE,  
    BOOL bIcons=TRUE,  
    CMFCTabCtrl::Location tabLocation=CMFCTabCtrl::LOCATION_BOTTOM,  
    BOOL bTabCloseButton=FALSE,  
    CMFCTabCtrl::Style style=CMFCTabCtrl::STYLE_3D_SCROLLED,  
    BOOL bTabCustomTooltips=FALSE,  
    BOOL bActiveTabCloseButton=FALSE);
```  
  
### <a name="parameters"></a>Parameter  
 `bEnable`  
 Gibt an, ob Registerkarten aktiviert sind.  
  
 `bIcons`  
 Gibt an, ob Symbole auf den Registerkarten angezeigt werden sollen.  
  
 `tabLocation`  
 Gibt den Speicherort der registerkartenbezeichnungen.  
  
 `bTabCloseButton`  
 Gibt an, ob Registerkarte schließen-Schaltflächen angezeigt werden soll.  
  
 `style`  
 Gibt den Stil der Registerkarten. Verwendung `STYLE_3D_SCROLLED` für normale Registerkarten oder `STYLE_3D_ONENOTE` für Microsoft OneNote-Registerkarten.  
  
 `bTabCustomTooltips`  
 Gibt an, ob QuickInfos aktiviert sind.  
  
 `bActiveTabCloseButton`  
 Wenn `TRUE`, **schließen** Schaltfläche auf der aktiven Registerkarte statt auf der rechten Ecke des Registerkartenbereichs angezeigt.  
  
### <a name="remarks"></a>Hinweise  
 Rufen Sie diese Methode zum Aktivieren oder deaktivieren Sie die MDI-Registerkarten für MDI-Rahmenfenster. Wenn diese Option aktiviert ist, werden alle untergeordneten Fenster als Registerkarten angezeigt.  
  
 Die registerkartenbezeichnungen am oberen oder unteren Rand des Rahmens, abhängig von der Einstellung des Parameters gefunden werden können `tabLocation`. Sie können entweder angeben `CMFCTabCtrl::LOCATION_BOTTOM` (Standardeinstellung) oder `CMFCTabCtrl::LOCATION_TOP`.  
  
 Wenn `bTabCustomTooltips` ist `TRUE`, eine `AFX_WM_ON_GET_TAB_TOOLTIP` Nachricht an das Hauptrahmenfenster gesendet werden. Der Code diese Meldung verarbeiten und geben Sie das Framework QuickInfos für MDI-Registerkarten.  
  
### <a name="example"></a>Beispiel  
 Das folgende Beispiel zeigt wie `EnableMDITabs` werden in der [MDITabsDemo-Beispiel: MFC-im Registerkartenformat MDI-Anwendung](../../visual-cpp-samples.md).  
  
 [!code-cpp[NVC_MFC_MDITabsDemo&3;](../../mfc/reference/codesnippet/cpp/cmdiframewndex-class_8.cpp)]  
  
##  <a name="enablemditabslastactiveactivation"></a>CMDIFrameWndEx::EnableMDITabsLastActiveActivation  
 Gibt an, ob die letzte aktive Registerkarte geöffnet werden soll, wenn der Benutzer die aktuelle Registerkarte geschlossen wird.  
  
```  
void EnableMDITabsLastActiveActivation(BOOL bLastActiveTab=TRUE);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `bLastActiveTab`  
 Wenn `TRUE`, aktivieren Sie die Aktivierung der letzten aktiven Registerkarte. Wenn `FALSE`, deaktivieren Sie die Aktivierung der letzten aktiven Registerkarte.  
  
### <a name="remarks"></a>Hinweise  
 Es gibt zwei Möglichkeiten, eine Registerkarte zu öffnen, wenn die aktive Registerkarte geschlossen wird:  
  
-   Aktivieren Sie die nächste Registerkarte.  
  
-   Aktivieren Sie die zuvor aktive Registerkarte.  
  
 Die standardmäßige Implementierung verwendet die erste Möglichkeit.  
  
 Verwendung `EnableMDITabsLastActiveActivation` bei der Aktivierung der Registerkarte zu aktivieren. Die Möglichkeit, die untergeordnete MDI-Fenster öffnen, emuliert.  
  
##  <a name="enablepanemenu"></a>CMDIFrameWndEx::EnablePaneMenu  
 Aktiviert oder deaktiviert die automatische Erstellung und Verwaltung von Popup im Menü, das eine Liste von Bereichen der Anwendung angezeigt.  
  
```  
void EnablePaneMenu(
    BOOL bEnable,  
    UINT uiCustomizeCmd,  
    const CString& strCustomizeLabel,  
    UINT uiViewToolbarsMenuEntryID,  
    BOOL bContextMenuShowsToolbarsOnly=FALSE,  
    BOOL bViewMenuShowsToolbarsOnly=FALSE);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `bEnable`  
 Wenn `TRUE`, automatische Behandlung von klicken Sie im Bereich aktiviert ist, wenn `FALSE`, automatische Behandlung ist deaktiviert.  
  
 [in] `uiCustomizeCmd`  
 Befehls-ID, der die **anpassen** Menüelement. Dieses Menüelement wird am Ende der Liste der Bereiche in der Regel hinzugefügt.  
  
 [in] `strCustomizeLabel`  
 Der Text für angezeigt werden die **anpassen** Menüelement (für Lokalisierung).  
  
 [in] `uiViewToolbarsMenuEntryID`  
 Gibt die ID eines Menüelements Symbolleiste, die das Menü geöffnet wird. Dies ist normalerweise der **Symbolleisten** Untermenü der **Ansicht** Menü.  
  
 [in] `bContextMenuShowsToolbarsOnly`  
 Wenn `TRUE`, klicken Sie im Bereich zeigt nur eine Liste der Symbolleisten. Wenn `FALSE`, klicken Sie im Menü zeigt eine Liste der Symbolleisten und Andocken Balken.  
  
 [in] `bViewMenuShowsToolbarsOnly`  
 Wenn `TRUE`, klicken Sie im Bereich zeigt nur eine Liste der Symbolleisten. Wenn `FALSE`, klicken Sie im Menü zeigt eine Liste der Symbolleisten und Andocken Balken.  
  
### <a name="remarks"></a>Hinweise  
 Klicken Sie im Popup-Fenster zeigt die Liste der Bereiche der Anwendung und ermöglicht dem Benutzer das ein- oder Ausblenden der einzelnen Bereiche.  
  
### <a name="example"></a>Beispiel  
 Das folgende Beispiel zeigt wie `EnablePaneMenu` werden in der [VisualStudioDemo-Beispiel: MFC-Anwendung für Visual Studio](../../visual-cpp-samples.md).  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo&#9;](../../mfc/codesnippet/cpp/cmdiframewndex-class_9.cpp)]  
  
##  <a name="enablewindowsdialog"></a>CMDIFrameWndEx::EnableWindowsDialog  
 Fügt ein Menüelement, dessen Befehls-ID Ruft, eine [CMFCWindowsManagerDialog](../../mfc/reference/cmfcwindowsmanagerdialog-class.md) das Dialogfeld.  
  
```  
void EnableWindowsDialog(
    UINT uiMenuId,  
    LPCTSTR lpszMenuText,  
    BOOL bShowAllways=FALSE,  
    BOOL bShowHelpButton=FALSE);

 
void EnableWindowsDialog(
    UINT uiMenuId,  
    UINT uiMenuTextResId,  
    BOOL bShowAllways=FALSE,  
    BOOL bShowHelpButton=FALSE);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `uiMenuId`  
 Gibt die Ressourcen-ID eines Menüs an.  
  
 [in] `lpszMenuText`  
 Gibt den Text des Elements an.  
  
 [in] `bShowHelpButton`  
 Gibt an, ob ein **Hilfe** Schaltfläche im Dialogfeld Windows-Verwaltung.  
  
 [in] `uiMenuTextResId`  
 Der Ressourcenbezeichner des Zeichenfolge, die Text-Zeichenfolge für das Element enthält.  
  
### <a name="remarks"></a>Hinweise  
 Mit dieser Methode können Sie ein Menüelement einfügen, deren Befehl eine MDI-untergeordneten Fenster Management-Dialogfeld ruft ( [CMFCWindowsManagerDialog Klasse](../../mfc/reference/cmfcwindowsmanagerdialog-class.md)). Das neue Element wird in das Menü angegebenen eingefügt `uiMenuId`. Rufen Sie `EnableWindowsDialog` beim Verarbeiten der `WM_CREATE` Nachricht.  
  
### <a name="example"></a>Beispiel  
 Das folgende Beispiel zeigt wie `EnableWindowsDialog` werden in der [VisualStudioDemo-Beispiel: MFC-Anwendung für Visual Studio](../../visual-cpp-samples.md).  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo&#10;](../../mfc/codesnippet/cpp/cmdiframewndex-class_10.cpp)]  
  
##  <a name="getactivepopup"></a>CMDIFrameWndEx::GetActivePopup  
 Gibt einen Zeiger auf das aktuell angezeigte Popupmenü zurück.  
  
```  
CMFCPopupMenu* GetActivePopup() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ein Zeiger auf das aktive Popupmenü; `NULL` Wenn keine Popupmenü aktiv ist.  
  
### <a name="remarks"></a>Hinweise  
 Mit dieser Funktion können Sie einen Zeiger auf die [CMFCPopupMenu Klasse](../../mfc/reference/cmfcpopupmenu-class.md) -Objekt, das derzeit angezeigt wird.  
  
##  <a name="getdefaultresid"></a>CMDIFrameWndEx::GetDefaultResId  
 Gibt die ID der freigegebenen Ressourcen des MDI-Rahmenfenster.  
  
```  
UINT GetDefaultResId() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ein Ressourcen-ID-Wert. 0, wenn das Rahmenfenster keine Menüleisten verfügt.  
  
### <a name="remarks"></a>Hinweise  
 Diese Methode gibt die Ressourcen-ID, die angegeben wurde, als MDI-Rahmenfenster von geladenen [CFrameWnd::LoadFrame](../../mfc/reference/cframewnd-class.md#loadframe).  
  
##  <a name="getmditabgroups"></a>CMDIFrameWndEx::GetMDITabGroups  
 Gibt eine Liste der MDI-Windows im Registerkartenformat zurück.  
  
```  
const CObList& GetMDITabGroups() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ein Verweis auf eine [CObList-Klasse](../../mfc/reference/coblist-class.md) -Objekt, das eine Liste von Fenstern im Registerkartenformat enthält. Speichern Sie oder ändern Sie die Liste nicht.  
  
### <a name="remarks"></a>Hinweise  
 Verwenden Sie diese Methode, um die Liste der im Registerformat zuzugreifen. Es kann hilfreich sein, wenn Sie verwenden möchten, ändern oder Abfragen einige Parameter von einzelnen Fenstern im Registerkartenformat.  
  
##  <a name="getmditabs"></a>CMDIFrameWndEx::GetMDITabs  
 Gibt einen Verweis auf die unterstrichenen Fenster im Registerkartenformat zurück.  
  
```  
CMFCTabCtrl& GetMDITabs();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ein Verweis auf die unterstrichenen Fenster im Registerkartenformat.  
  
##  <a name="getmditabscontextmenualloweditems"></a>CMDIFrameWndEx::GetMDITabsContextMenuAllowedItems  
 Gibt eine Kombination von Flags, die bestimmt, welche Vorgänge gültig sind, wenn das Feature im Registerkartenformat MDI-Gruppen aktiviert ist.  
  
```  
DWORD GetMDITabsContextMenuAllowedItems();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Eine bitweise OR-Kombination der folgenden Flags:  
  
- `BCGP_MDI_CREATE_VERT_GROUP`-eine vertikale Registerkartengruppe erstellen können.  
  
- `BCGP_MDI_CREATE_HORZ_GROUP`-eine horizontale Registerkartengruppe erstellen können.  
  
- `BCGP_MDI_CAN_MOVE_PREV`-eine Registerkarte zur der vorherigen Registerkartengruppe wechseln können.  
  
- `BCGP_MDI_CAN_MOVE_NEXT`-kann eine Registerkarte zur nächsten Registerkartengruppe wechseln.  
  
### <a name="remarks"></a>Hinweise  
 Wenn das Feature im Registerkartenformat MDI-Gruppen aktiviert ist, müssen Sie wissen, welche Vorgänge auf den Registerkarten eines bestimmten Fensters zulässig sind. Diese Methode analysiert das aktuelle Layout des im Registerformat und gibt eine Kombination von Flags, die sein können verwendeten zu erstellen, z. B. ein Kontextmenü.  
  
 Sie können eine neue vertikale Registerkartengruppe erstellen, wenn alle Fenster im Registerformat vertikal ausgerichtet werden, oder wenn nur ein Fenster im Registerkartenformat.  
  
 Sie können eine neue horizontale Registerkartengruppe erstellen, wenn alle Fenster im Registerformat horizontal ausgerichtet werden, oder wenn nur ein Fenster im Registerkartenformat.  
  
 Sie können eine Registerkarte zur vorherigen Gruppe verschieben, nur dann, wenn mehrere Registerkarten in einem Fenster im Registerkartenformat.  
  
 Sie können eine Registerkarte zur nächsten Gruppe verschieben, nur dann, wenn mehrere Registerkarten in einem Fenster im Registerkartenformat.  
  
##  <a name="getmenubar"></a>CMDIFrameWndEx::GetMenuBar  
 Gibt einen Zeiger auf ein Menü Bar-Objekt an das Rahmenfenster angefügt.  
  
```  
const CMFCMenuBar* GetMenuBar() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ein Zeiger auf ein Menü Bar-Objekt.  
  
##  <a name="getpane"></a>CMDIFrameWndEx::GetPane  
 Gibt einen Zeiger auf den Bereich, der die angegebene Steuerelement-ID verfügt.  
  
```  
CBasePane* GetPane(UINT nID);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `nID`  
 Die Steuerelement-ID.  
  
### <a name="return-value"></a>Rückgabewert  
 Ein Zeiger auf den Bereich, die die angegebene Steuerelement-ID, sofern vorhanden. Andernfalls `NULL`.  
  
##  <a name="getribbonbar"></a>CMDIFrameWndEx::GetRibbonBar  
 Ruft die Menüband-Steuerelement für den Rahmen.  
  
```  
CMFCRibbonBar* GetRibbonBar();
```  
  
### <a name="return-value"></a>Rückgabewert  
 Zeiger auf die [CMFCRibbonBar Class](../../mfc/reference/cmfcribbonbar-class.md) für den Frame.  
  
### <a name="remarks"></a>Hinweise  
  
##  <a name="gettearoffbars"></a>CMDIFrameWndEx::GetTearOffBars  
 Gibt eine Liste von abtrennbare Menüs.  
  
```  
const CObList& GetTearOffBars() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 Ein Verweis auf eine [CObList-Klasse](../../mfc/reference/coblist-class.md) -Objekt, das eine Auflistung von Zeigern auf enthält `CPane`-abgeleitete Objekte, die in einem abtrennbare Zustand befinden.  
  
### <a name="remarks"></a>Hinweise  
 `CMDIFrameWndEx`verwaltet eine Auflistung von abtrennbare Menüs. Verwenden Sie diese Methode, um einen Verweis auf diese Liste abzurufen.  
  
##  <a name="gettoolbarbuttontooltiptext"></a>CMDIFrameWndEx::GetToolbarButtonToolTipText  
 Vom Framework aufgerufen, wenn die Anwendung die QuickInfo für eine Symbolleisten-Schaltfläche angezeigt wird.  
  
```  
virtual BOOL GetToolbarButtonToolTipText(
    CMFCToolBarButton* pButton,  
    CString& strTTText);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `pButton`  
 Ein Zeiger auf eine Symbolleisten-Schaltfläche.  
  
 [in] `strTTText`  
 Der QuickInfo-Text für die Schaltfläche angezeigt.  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn die QuickInfo angezeigt wird. Andernfalls `FALSE`.  
  
### <a name="remarks"></a>Hinweise  
  
##  <a name="insertpane"></a>CMDIFrameWndEx::InsertPane  
 Registriert den angegebenen Bereich der docking-Manager.  
  
```  
BOOL InsertPane(
    CBasePane* pControlBar,  
    CBasePane* pTarget,  
    BOOL bAfter=TRUE);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `pControlBar`  
 Ein Zeiger auf den Bereich eingefügt werden.  
  
 [in] `pTarget`  
 Ein Zeiger auf den Bereich, die vor oder nach dem Bereich eingefügt.  
  
 [in] `bAfter`  
 Wenn `TRUE`, `pControlBar` eingefügt wird, nachdem `pTarget`. Wenn `FALSE`, `pControlBar` wird eingefügt, bevor Sie `pTarget`.  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn die Methode erfolgreich Bereich registriert `FALSE` Wenn Bereich docking-Manager bereits registriert wurde.  
  
### <a name="remarks"></a>Hinweise  
 Mit dieser Methode können Sie einen angegebenen Bereich den Dockingstation Manager mitteilen `pControlBar`. Der docking-Manager wird dieser Bereich im Bereichs Ausrichtung und Position in der Dockingstation Manager internen Liste ausgerichtet.  
  
##  <a name="isfullscreen"></a>CMDIFrameWndEx::IsFullScreen  
 Bestimmt, ob das Rahmenfenster in den Vollbildmodus.  
  
```  
BOOL IsFullScreen() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn das Rahmenfenster im Vollbildmodus ist. andernfalls `FALSE`.  
  
### <a name="remarks"></a>Hinweise  
 Sie können den Vollbildmodus festlegen, durch Aufrufen der [CMDIFrameWndEx::EnableFullScreenMode](#enablefullscreenmode) Methode.  
  
##  <a name="ismditabbedgroup"></a>CMDIFrameWndEx::IsMDITabbedGroup  
 Gibt an, ob das Feature im Registerkartenformat MDI-Gruppen aktiviert ist.  
  
```  
BOOL IsMDITabbedGroup() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn das Feature im Registerkartenformat MDI-Gruppen aktiviert ist; andernfalls `FALSE`.  
  
### <a name="remarks"></a>Hinweise  
 Bestimmt, ob die normale MDI-Registerkarten oder das Feature im Registerkartenformat MDI-Gruppen aktiviert ist, verwenden Sie [CMDIFrameWndEx::AreMDITabs](#aremditabs).  
  
##  <a name="ismemberofmditabgroup"></a>CMDIFrameWndEx::IsMemberOfMDITabGroup  
 Bestimmt, ob das angegebene Fenster im Registerkartenformat in der Liste von Windows, die im MDI-Gruppen im Registerkartenformat sind.  
  
```  
BOOL IsMemberOfMDITabGroup(CWnd* pWnd);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `pWnd`  
 Ein Zeiger auf Fenster im Registerkartenformat.  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn das angegebene Fenster im Registerkartenformat ist in der Liste der im Registerformat, die MDI-Gruppen im Registerkartenformat zu bilden. Andernfalls `FALSE`.  
  
##  <a name="ismenubaravailable"></a>CMDIFrameWndEx::IsMenuBarAvailable  
 Bestimmt, ob das Rahmenfenster Menüleiste.  
  
```  
BOOL IsMenuBarAvailable() const;  
```  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`der Zeiger auf das Menü Bar-Objekt ist nicht `NULL`andernfalls `FALSE`.  
  
##  <a name="ispointneardocksite"></a>CMDIFrameWndEx::IsPointNearDockSite  
 Bestimmt, ob es sich bei ein angegebenen Punkt in der Nähe der Dock-Website befindet.  
  
```  
BOOL IsPointNearDockSite(
    CPoint point,  
    DWORD& dwBarAlignment,  
    BOOL& bOuterEdge) const;  
```  
  
### <a name="parameters"></a>Parameter  
 [in] `point`  
 Der angegebene Punkt in Bildschirmkoordinaten.  
  
 [in] `dwBarAlignment`  
 Gibt an, welchen Rand in der Nähe der Punkt ist. Mögliche Werte sind `CBRS_ALIGN_LEFT`, `CBRS_ALIGN_RIGHT`, `CBRS_ALIGN_TOP`, und`CBRS_ALIGN_BOTTOM`  
  
 [in] `bOuterEdge`  
 `TRUE`Wenn der Punkt in der Nähe von den äußeren Rahmen des Standorts Dock ist; `FALSE` andernfalls.  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn der Punkt in der Nähe der Dock-Website ist. andernfalls `FALSE`.  
  
### <a name="remarks"></a>Hinweise  
 Der Punkt ist in der Nähe der docksite, wenn es innerhalb der Vertraulichkeit in der Dockingstation Manager festgelegt ist. Die Vertraulichkeit der Standardwert beträgt 15 Pixel.  
  
##  <a name="isprintpreview"></a>CMDIFrameWndEx::IsPrintPreview  
 Bestimmt, ob das Rahmenfenster in den Seitenansicht-Modus.  
  
```  
BOOL IsPrintPreview();
```  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn das Rahmenfenster in den Seitenansicht-Modus ist. andernfalls `FALSE`.  
  
### <a name="remarks"></a>Hinweise  
  
##  <a name="loadframe"></a>CMDIFrameWndEx::LoadFrame  
 Erstellt ein Rahmenfenster von Ressourceninformationen.  
  
```  
virtual BOOL LoadFrame(
    UINT nIDResource,  
    DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE,  
    CWnd* pParentWnd = NULL,  
    CCreateContext* pContext = NULL);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `nIDResource`  
 Die ID einer freigegebenen Ressource das Rahmenfenster zugeordnet.  
  
 [in] `dwDefaultStyle`  
 Der Stil des Rahmenfensters.  
  
 [in] `pParentWnd`  
 Ein Zeiger auf den Rand des übergeordneten.  
  
 [in] `pContext`  
 Ein Zeiger auf eine [angegeben ist und Struktur](../../mfc/reference/ccreatecontext-structure.md). Dieser Parameter kann `NULL` sein.  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn die Methode erfolgreich, andernfalls ist `FALSE`.  
  
##  <a name="loadmdistate"></a>CMDIFrameWndEx::LoadMDIState  
 Lädt das angegebene Layout im Registerkartenformat MDI-Gruppen und die Liste der zuvor geöffneten Dokumente.  
  
```  
virtual BOOL LoadMDIState(LPCTSTR lpszProfileName);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `lpszProfileName`  
 Gibt den Namen des Profils an.  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn der Ladevorgang erfolgreich war; `FALSE` Fehler beim Laden oder es sind keine Daten geladen.  
  
### <a name="remarks"></a>Hinweise  
 Zum Laden oder speichern Sie den Status der MDI-Registerkarten und Gruppen und die Liste der geöffneten Dokumente, führen Sie folgende Schritte aus:  
  
-   Rufen Sie [CMDIFrameWndEx::SaveMDIState](#savemdistate) , wenn der Hauptframe wird geschlossen  
  
-   Rufen Sie [CMDIFrameWndEx::LoadMDIState](#loadmdistate) Wenn Hauptframe erstellt wird. Am besten platzieren, damit dieser Aufruf ist, bevor der Hauptframe zum ersten Mal angezeigt wird. Hinzufügen `CWinAppEx::EnableLoadWindowPlacement` `(FALSE);` vor `pMainFrame->LoadFrame (IDR_MAINFRAME);.` hinzufügen `CBCGPWorkspace::ReloadWindowPlacement` `(pMainFrame);` nach dem Aufruf von `LoadMDIState` Hauptframe an der Position angezeigt, die in der Registrierung gespeichert wurde.  
  
-   Überschreiben Sie `GetDocumentName` in der `CMDIChildWndEx`-abgeleitete Klasse, wenn Ihre Anwendung Dokumente angezeigt, die nicht als Dateien gespeichert werden. Die zurückgegebene Zeichenfolge wird als Dokument-ID in der Registrierung gespeichert. Die basisimplementierung [CMDIChildWndEx::GetDocumentName](../../mfc/reference/cmdichildwndex-class.md#getdocumentname) gibt einen Wert, der vom [CDocument::GetPathName](../../mfc/reference/cdocument-class.md#getpathname).  
  
-   Überschreiben Sie [CMDIFrameWndEx::CreateDocumentWindow](#createdocumentwindow) Dokumente ordnungsgemäß zu erstellen, wenn diese aus der Registrierung geladen werden. Der erste Parameter ist die Zeichenfolge, die `GetDocumentName` zurückgegeben.  
  
### <a name="example"></a>Beispiel  
 Das folgende Beispiel zeigt wie `LoadMDIState` werden in der [VisualStudioDemo-Beispiel: MFC-Anwendung für Visual Studio](../../visual-cpp-samples.md).  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo&#11;](../../mfc/codesnippet/cpp/cmdiframewndex-class_11.cpp)]  
  
##  <a name="mditabmovetonextgroup"></a>CMDIFrameWndEx::MDITabMoveToNextGroup  
 Verschiebt die aktive Registerkarte aus der aktuell aktiven Fenster im Registerkartenformat an den nächsten oder vorherigen Registerkartengruppe.  
  
```  
void MDITabMoveToNextGroup(BOOL bNext=TRUE);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `bNext`  
 Wenn `TRUE`, verschieben Sie die Registerkarte zur nächsten Gruppe im Registerkartenformat. Wenn `FALSE`, verschieben Sie sie an der vorherigen Gruppe im Registerkartenformat.  
  
##  <a name="mditabnewgroup"></a>CMDIFrameWndEx::MDITabNewGroup  
 Erstellt eine neue Registerkarte Gruppe, die ein einzelnes Fenster.  
  
```  
void MDITabNewGroup(BOOL bVert=TRUE);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `bVert`  
 Gibt die Ausrichtung der neuen Gruppe. Wenn `TRUE`, die neue Gruppe wird vertikal ausgerichtet. Wenn `FALSE`, die neue Gruppe wird horizontal ausgerichtet.  
  
### <a name="remarks"></a>Hinweise  
 Verwenden Sie diese Funktion zum Erstellen eines neuen im Registerkartenformat Fenster (neue Gruppe im Registerkartenformat), und fügen Sie die erste Registerkarte hinzu.  
  
### <a name="example"></a>Beispiel  
 Das folgende Beispiel zeigt wie `MDITabNewGroup` werden in der [VisualStudioDemo-Beispiel: MFC-Anwendung für Visual Studio](../../visual-cpp-samples.md).  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo&#12;](../../mfc/codesnippet/cpp/cmdiframewndex-class_12.cpp)]  
  
##  <a name="m_bcancovertcontrolbartomdichild"></a>CMDIFrameWndEx::m_bCanCovertControlBarToMDIChild  
 Gibt an, ob untergeordnete MDI-Fenster andockbare Bereiche konvertiert werden können.  
  
```  
BOOL m_bCanCovertControlBarToMDIChild;  
```  
  
### <a name="remarks"></a>Hinweise  
 Gibt an, ob andockbarer Steuerleisten in untergeordneten MDI-Fenstern konvertiert werden können. Wenn dieses Flag ist `TRUE`, das Framework übernimmt die Konvertierung automatisch bei der Auswahl der **Dokument im Registerkartenformat** Befehl. Das Flag ist geschützt, und Sie müssen diese Option explizit aktivieren durch Festlegen von `m_bCanCovertControlBarToMDIChild` in einem Konstruktor, der eine `CMDIFrameWndEx`-abgeleitete Klasse oder durch Überschreiben der `CanConvertControlBarToMDIChild`.  
  
 Der Standardwert ist `FALSE`.  
  
### <a name="example"></a>Beispiel  
 Das folgende Beispiel zeigt wie `m_bCanCovertControlBarToMDIChild` werden in der [VisualStudioDemo-Beispiel: MFC-Anwendung für Visual Studio](../../visual-cpp-samples.md).  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo&#13;](../../mfc/codesnippet/cpp/cmdiframewndex-class_2.cpp)]  
  
##  <a name="m_bdisablesetredraw"></a>CMDIFrameWndEx::m_bDisableSetRedraw  
 Aktiviert oder deaktiviert die Neuzeichnen Optimierung für untergeordnete MDI-Fenster.  
  
```  
AFX_IMPORT_DATA static BOOL m_bDisableSetRedraw;  
```  
  
### <a name="remarks"></a>Hinweise  
 Der Standardwert ist `TRUE`.  
  
 Legen Sie dieses Flag auf `FALSE` sollten Sie das Neuzeichnen der untergeordnete MDI-Fenster zu optimieren. In diesem Fall ruft das Framework `SetRedraw (FALSE)` für den Hauptframe, wenn die Anwendung die aktive Registerkarte geändert wird.  
  
 Dieses Flag kann dazu führen, dass unerwünschte Nebeneffekte auftreten (z. B. Programme im Hintergrund, die sichtbar werden). Daher wird empfohlen, dass Sie die Standardeinstellung ändern, nur, wenn Sie auftreten spürbaren Flimmern während der Aktivierung der MDI-Registerkarte.  
  
##  <a name="negotiateborderspace"></a>CMDIFrameWndEx::NegotiateBorderSpace  
 Verhandelt Rahmen Speicherplatz in einem Rahmenfenster während OLE-Ort-Aktivierung.  
  
```  
virtual BOOL NegotiateBorderSpace(
    UINT nBorderCmd,  
    LPRECT lpRectBorder);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `nBorderCmd`  
 Enthält die folgenden Werte aus der Enumeration `CFrameWnd::BorderCmd`:  
  
- `borderGet` = 1  
  
- `borderRequest` = 2  
  
- `borderSet` = 3  
  
 [in, out] `lpRectBorder`  
 Zeiger auf eine [RECT-Struktur](../../mfc/reference/rect-structure1.md) oder [CRect Class](../../atl-mfc-shared/reference/crect-class.md) -Objekt, das die Koordinaten des Rahmens angibt.  
  
### <a name="return-value"></a>Rückgabewert  
 Der Wert ist ungleich NULL, wenn die Methode erfolgreich war; andernfalls 0.  
  
### <a name="remarks"></a>Hinweise  
 Diese Methode ist eine Implementierung von OLE Rahmen Speicherplatz Aushandlung.  
  
##  <a name="onclosedockingpane"></a>CMDIFrameWndEx::OnCloseDockingPane  
 Vom Framework aufgerufen, wenn der Benutzer klickt auf die **schließen** auf einen andockbaren Bereich auf die Schaltfläche.  
  
```  
virtual BOOL OnCloseDockingPane(CDockablePane* pWnd);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `pWnd`  
 Ein Zeiger auf den Bereich geschlossen wird.  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn die andockbaren geschlossen werden kann. Andernfalls `FALSE`.  
  
### <a name="remarks"></a>Hinweise  
 Überschreiben Sie diese Methode zum Ausblenden des andockbare Bereiche zu behandeln. Zurückgeben `FALSE` , wenn Sie verhindern, einen andockbaren Bereich ausgeblendet möchten.  
  
 Die standardmäßige Implementierung keine Aktion aus und gibt `TRUE`.  
  
##  <a name="oncloseminiframe"></a>CMDIFrameWndEx::OnCloseMiniFrame  
 Vom Framework aufgerufen, wenn der Benutzer klickt auf die **schließen** Schaltfläche schwebenden Minirahmenfenster.  
  
```  
virtual BOOL OnCloseMiniFrame(CPaneFrameWnd*);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `pWnd`  
 Ein Zeiger auf das Minirahmenfenster geschlossen wird.  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn die schwebenden Minirahmenfenster geschlossen werden kann. Andernfalls `FALSE`.  
  
### <a name="remarks"></a>Hinweise  
 Überschreiben Sie diese Methode zum Ausblenden von veränderlichem Minirahmenfenster behandeln. Zurückgeben `FALSE` Wenn verhindern, dass ein Gleitkomma Minirahmenfenster ausgeblendet werden soll.  
  
 Die standardmäßige Implementierung keine Aktion aus und gibt `TRUE`.  
  
##  <a name="onclosepopupmenu"></a>CMDIFrameWndEx::OnClosePopupMenu  
 Vom Framework aufgerufen, wenn eine aktive Popupmenü verarbeitet eine `WM_DESTROY` Nachricht.  
  
```  
virtual void OnClosePopupMenu(CMFCPopupMenu* pMenuPopup);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `pMenuPopup`  
 Ein Zeiger auf ein Popup-Menü.  
  
### <a name="remarks"></a>Hinweise  
 Überschreiben Sie diese Methode, wenn Sie Nachrichten aus dem verarbeiten möchten [CMFCPopupMenu Klasse](../../mfc/reference/cmfcpopupmenu-class.md) Objekte, die an das MDI-Rahmenfenster gehören, wenn diese Objekte verarbeiten `WM_DESTROY` Nachrichten.  
  
##  <a name="oncmdmsg"></a>CMDIFrameWndEx::OnCmdMsg  
 Vom Framework aufgerufen, weiterleiten und verteilen Befehl Nachrichten und Befehlsobjekte Benutzeroberfläche aktualisieren.  
  
```  
virtual BOOL OnCmdMsg(
    UINT nID,  
    int nCode,  
    void* pExtra,  
    AFX_CMDHANDLERINFO* pHandlerInfo);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `nID`  
 Die Befehls-ID.  
  
 [in] `nCode`  
 Identifiziert den Befehl Benachrichtigungscode. Finden Sie unter [CCmdTarget::OnCmdMsg](../../mfc/reference/ccmdtarget-class.md#oncmdmsg) Weitere Informationen zu den Werten für `nCode`.  
  
 [in] `pExtra`  
 Entsprechend dem Wert der verwendeten `nCode`. Finden Sie unter [CCmdTarget::OnCmdMsg](../../mfc/reference/ccmdtarget-class.md#oncmdmsg) Weitere Informationen zu `pExtra`.  
  
 [in, out] `pHandlerInfo`  
 Dieser Parameter sollte in der Regel `NULL`. Wenn nicht `NULL`, `OnCmdMsg` füllt die `pTarget` und `pmf` Mitglieder der `pHandlerInfo` Struktur, anstatt den Befehl zu verteilen.  
  
### <a name="return-value"></a>Rückgabewert  
 Wert ungleich NULL, wenn die Nachricht verarbeitet wird; andernfalls 0.  
  
##  <a name="ondrawmenuimage"></a>CMDIFrameWndEx::OnDrawMenuImage  
 Wird vom Framework aufgerufen, wenn das einem Menüelement zugeordnete Bild gezeichnet wird.  
  
```  
virtual BOOL OnDrawMenuImage(
    CDC* pDC,  
    const CMFCToolBarMenuButton* pMenuButton,  
    const CRect& rectImage);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `pDC`  
 Zeiger zu einem Gerätekontext.  
  
 [in] `pMenuButton`  
 Ein Zeiger auf die Schaltfläche.  
  
 [in] `rectImage`  
 Umschließende Rechteck des Bilds.  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn die Methode das Bild zeichnet. Die Standardimplementierung gibt `FALSE` zurück.  
  
### <a name="remarks"></a>Hinweise  
 Überschreiben Sie diese Methode, wenn anzupassende Bildrendering für die Menüelemente, die auf der Menüleiste, die im Besitz von gehören die `CMDIFrameWndEx`-abgeleitetes Objekt. Bei der Standardimplementierung wird keine Aktion ausgeführt.  
  
##  <a name="ondrawmenulogo"></a>CMDIFrameWndEx::OnDrawMenuLogo  
 Aufgerufen, wenn ein [CMFCPopupMenu](../../mfc/reference/cmfcpopupmenu-class.md)Prozesse eine `WM_PAINT` Nachricht.  
  
```  
virtual void OnDrawMenuLogo(
    CDC*, 
    CMFCPopupMenu*, 
    const CRect&);
```  
  
### <a name="remarks"></a>Hinweise  
 Überschreiben Sie diese Funktion, um ein Logo im Popupmenü anzeigen, die auf der Menüleiste, die im Besitz von gehört das `CMDIFrameWndEx`-abgeleitetes Objekt. Bei der Standardimplementierung wird keine Aktion ausgeführt.  
  
##  <a name="onerasemdiclientbackground"></a>CMDIFrameWndEx::OnEraseMDIClientBackground  
 Vom Framework aufgerufen, wenn der frame MDI-Fenster Prozesse eine `WM_ERASEBKGND` Nachricht.  
  
```  
virtual BOOL OnEraseMDIClientBackground(CDC*);
```  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn die Anwendung die Nachricht verarbeitet und den Hintergrund löscht.  
  
### <a name="remarks"></a>Hinweise  
 Überschreiben Sie diese Memberfunktion auf, wenn Sie verarbeiten möchten die `WM_ERASEBKGND` Nachricht in eine `CMDIFrameWndEx`-Klasse.  
  
##  <a name="onmenubuttontoolhittest"></a>CMDIFrameWndEx::OnMenuButtonToolHitTest  
 Vom Framework aufgerufen wird bei einer [CMFCToolBarButton](../../mfc/reference/cmfctoolbarbutton-class.md)-Objekt Prozesse eine `WM_NCHITTEST` Nachricht.  
  
```  
virtual BOOL OnMenuButtonToolHitTest(
    CMFCToolBarButton* pButton,  
    TOOLINFO* pTI);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `pButton`  
 Die Symbolleisten-Schaltfläche.  
  
 [out] `pTI`  
 Zeiger auf eine [TOOLINFO](http://msdn.microsoft.com/library/windows/desktop/bb760256) Struktur.  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn die Anwendung füllt die `pTI` Parameter. Die Standardimplementierung gibt `FALSE` zurück.  
  
### <a name="remarks"></a>Hinweise  
 Überschreiben Sie diese Methode, wenn Sie Informationen über bestimmte Menüelemente zu einer QuickInfo bereitstellen möchten. Bei der Standardimplementierung wird keine Aktion ausgeführt.  
  
##  <a name="onmoveminiframe"></a>CMDIFrameWndEx::OnMoveMiniFrame  
 Aufgerufen, um ein Minirahmenfenster zu verschieben.  
  
```  
virtual BOOL OnMoveMiniFrame(CWnd* pFrame);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `pFrame`  
 Ein Zeiger auf ein Minirahmenfenster.  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn die Methode erfolgreich, andernfalls ist `FALSE`.  
  
##  <a name="onsetpreviewmode"></a>CMDIFrameWndEx::OnSetPreviewMode  
 Legt die Anwendung Hauptframe Fenster Seitenansicht Modus fest.  
  
```  
virtual void OnSetPreviewMode(
    BOOL bPreview,  
    CPrintPreviewState* pState);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `bPreview`  
 Wenn `TRUE`, Seitenansicht Modus festgelegt. Wenn `FALSE`, bricht Vorschaumodus.  
  
 [in] `pState`  
 Ein Zeiger auf eine `CPrintPreviewState` Struktur.  
  
### <a name="remarks"></a>Hinweise  
 Diese Methode überschreibt [CFrameWnd::OnSetPreviewMode](../../mfc/reference/cframewnd-class.md#onsetpreviewmode).  
  
##  <a name="onshowcustomizepane"></a>CMDIFrameWndEx::OnShowCustomizePane  
 Wird vom Framework aufgerufen, wenn ein Bereich Quick anpassen aktiviert wird.  
  
```  
virtual BOOL OnShowCustomizePane(
    CMFCPopupMenu* pMenuPane,  
    UINT uiToolbarID);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `pMenuPane`  
 Ein Zeiger auf den Bereich schnell anpassen.  
  
 [in] `uiToolbarID`  
 Steuerelement-ID der Symbolleiste anpassen.  
  
### <a name="return-value"></a>Rückgabewert  
 Diese Methode gibt immer `TRUE` zurück.  
  
### <a name="remarks"></a>Hinweise  
 Der Bereich Quick anpassen wird ein Menü, das geöffnet wird, wenn der Benutzer klickt auf **anpassen** auf einer Symbolleiste.  
  
 Überschreiben Sie diese Methode in einer abgeleiteten Klasse zu ändern, klicken Sie im Bereich Quick anpassen.  
  
##  <a name="onshowmditabcontextmenu"></a>CMDIFrameWndEx::OnShowMDITabContextMenu  
 Vom Framework aufgerufen, bevor ein Kontextmenü auf eine der Registerkarten angezeigt wird. Gültig für MDI-Gruppen nur im Registerkartenformat.  
  
```  
virtual BOOL OnShowMDITabContextMenu(
    CPoint point,  
    DWORD dwAllowedItems,  
    BOOL bTabDrop);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `point`  
 Die Position des Menüs in Bildschirmkoordinaten.  
  
 [in] `dwAllowedItems`  
 Eine bitweise OR-Kombination von Flags, die angibt, welche Aktionen für die aktuelle Registerkarte zulässig sind:  
  
- `BCGP_MDI_CREATE_VERT_GROUP`-eine vertikale Registerkartengruppe erstellen können.  
  
- `BCGP_MDI_CREATE_HORZ_GROUP`-eine horizontale Registerkartengruppe erstellen können.  
  
- `BCGP_MDI_CAN_MOVE_PREV`-eine Registerkarte zur der vorherigen Registerkartengruppe wechseln können.  
  
- `BCGP_MDI_CAN_MOVE_NEXT`-kann eine Registerkarte zur nächsten Registerkartengruppe wechseln.  
  
- `BCGP_MDI_CAN_BE_DOCKED`-ein Dokument im Registerkartenformat angedockten Zustand (relevant für nur Dokumente im Registerformat) wechseln.  
  
 [in] `bTabDrop`  
 `TRUE`Klicken Sie im Menü durch Ziehen von der Registerkarte auf eine andere Gruppe im Registerkartenformat angezeigt. `FALSE`Klicken Sie im Menü als Kontextmenü auf der aktiven Registerkarte angezeigt.  
  
### <a name="return-value"></a>Rückgabewert  
 Überschreiben Sie diese Methode in einer [CBCGPMDIFrameWnd](../../mfc/reference/cmdiframewndex-class.md)-abgeleiteten Klasse.  
  
### <a name="remarks"></a>Hinweise  
 Wenn Sie keine verarbeiten `OnShowMDITabContextMenu`, im Kontextmenü nicht angezeigt. Diese Funktion wird generiert, indem die **MFC Application Wizard** Wenn Sie das Feature im Registerkartenformat MDI-Gruppen aktivieren.  
  
### <a name="example"></a>Beispiel  
 Das folgende Beispiel zeigt wie `OnShowMDITabContextMenu` werden in der [VisualStudioDemo-Beispiel: MFC-Anwendung für Visual Studio](../../visual-cpp-samples.md).  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo&14;](../../mfc/codesnippet/cpp/cmdiframewndex-class_13.cpp)]  
  
##  <a name="onshowpanes"></a>CMDIFrameWndEx::OnShowPanes  
 Vom Framework aufgerufen wird, anzeigen oder Ausblenden von Bereichen.  
  
```  
virtual BOOL OnShowPanes(BOOL bShow);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `bShow`  
 `TRUE`Bereiche anzeigen `FALSE` Bereiche ausblenden.  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn der Zustand der Bereiche ändert, durch das Aufrufen dieser Methode `FALSE` Wenn die Bereiche bereits im angegebenen Zustand `bShow`. Beispielsweise, wenn die Bereiche ausgeblendet sind und `bShow` ist `FALSE`, der Rückgabewert ist `FALSE`.  
  
### <a name="remarks"></a>Hinweise  
 Die standardmäßige Implementierung entfernt die Symbolleiste im Fenster der obersten Ebene Frame.  
  
 Wenn [CDockingManager::m_bHideDockingBarsInContainerMode](../../mfc/reference/cdockingmanager-class.md#m_bhidedockingbarsincontainermode) ist `TRUE` (Standard), alle andockbare Bereiche ausgeblendet werden.  
  
##  <a name="onshowpopupmenu"></a>CMDIFrameWndEx::OnShowPopupMenu  
 Vom Framework aufgerufen, wenn sie ein Popup-Menü geöffnet wird.  
  
```  
virtual BOOL OnShowPopupMenu(CMFCPopupMenu*);
```  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn das Popupmenü angezeigt werden. Andernfalls `FALSE`. Die Standardimplementierung gibt `TRUE` zurück.  
  
### <a name="remarks"></a>Hinweise  
 Überschreiben Sie diese Methode, wenn Sie speziellen Verarbeitung nach der Aktivierung von Popupmenü implementieren möchten. Z. B. Wenn Sie normale Menüelemente in Menüschaltflächen Farbe ändern möchten, richten Sie abtrennbare Balken, usw.  
  
 Bei der Standardimplementierung wird keine Aktion ausgeführt.  
  
##  <a name="onsizemdiclient"></a>CMDIFrameWndEx::OnSizeMDIClient  
 Vom Framework aufgerufen, wenn die Größe des MDI-Clientfenster geändert wird.  
  
```  
virtual void OnSizeMDIClient(
    const CRect& rectOld,  
    const CRect& rectNew);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `rectOld`  
 Die aktuelle Größe des Fensters MDI-Client.  
  
 [in] `rectNew`  
 Die neue Größe des Fensters MDI-Client.  
  
### <a name="remarks"></a>Hinweise  
  
##  <a name="ontearoffmenu"></a>CMDIFrameWndEx::OnTearOffMenu  
 Wird vom Framework aufgerufen, wenn ein Menü mit abtrennbarer Leiste aktiviert wird.  
  
```  
virtual BOOL OnTearOffMenu(
    CMFCPopupMenu* pMenuPopup,  
    CPane* pBar);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `pMenuPopup`  
 Ein Zeiger auf die Popup-Menü.  
  
 [in] `pBar`  
 Ein Zeiger auf die Leiste abtrennbare.  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Um mit der Leiste abtrennbare vorgenommen werden, aktivieren Sie im Popupmenü zu ermöglichen. andernfalls `FALSE`. Die Standardeinstellung ist `TRUE`.  
  
### <a name="remarks"></a>Hinweise  
 Überschreiben Sie diese Funktion, wenn Sie eine spezielle Einrichtung für die Leiste abtrennbare implementieren möchten. Bei der Standardimplementierung wird keine Aktion ausgeführt.  
  
##  <a name="onupdateframemenu"></a>CMDIFrameWndEx::OnUpdateFrameMenu  
 Vom Framework aufgerufen wird, klicken Sie im Frame zu aktualisieren.  
  
```  
virtual void OnUpdateFrameMenu(HMENU hMenuAlt);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `hMenuAlt`  
 Ein Handle für ein Menü.  
  
##  <a name="panefrompoint"></a>CMDIFrameWndEx::PaneFromPoint  
 Gibt die andockbaren Bereich, der den angegebenen Punkt enthält.  
  
```  
CBasePane* PaneFromPoint(
    CPoint point,  
    int nSensitivity,  
    bool bExactBar,  
    CRuntimeClass* pRTCBarType) const;  
  
CBasePane* PaneFromPoint(
    CPoint point,  
    int nSensitivity,  
    DWORD& dwAlignment,  
    CRuntimeClass* pRTCBarType) const;  
```  
  
### <a name="parameters"></a>Parameter  
 [in] `point`  
 Der Punkt (in Bildschirmkoordinaten).  
  
 [in] `nSensitivity`  
 Das Fenster Rechteck für jeden aktivierten Bereich wird in alle Richtungen durch diesen Wert vergrößert.  
  
 [in] `bExactBar`  
 Wenn `TRUE`der `nSensitivity` Parameter wird ignoriert.  
  
 [in] `pRTCBarType`  
 Bei nicht - `NULL`, die Methode durchläuft nur die Bereiche des angegebenen Typs.  
  
 [out] `dwAlignment`  
 Wenn ein Bereich gefunden wird, wird diesen Parameter angeben, welche Seite des Bereichs der angegebenen Punkt am nächsten ist.  
  
### <a name="return-value"></a>Rückgabewert  
 Ein Zeiger auf einen andockbaren Bereich, oder `NULL` Wenn keine Kontrolle über den vom angegebenen Punkt enthält `point`.  
  
### <a name="remarks"></a>Hinweise  
 Der Aufruf wird an umgeleitet, die [CDockingManager Klasse](../../mfc/reference/cdockingmanager-class.md). Finden Sie unter [CDockingManager::ControlBarFromPoint](../../mfc/reference/cdockingmanager-class.md#panefrompoint) Weitere Informationen.  
  
##  <a name="recalclayout"></a>CMDIFrameWndEx::RecalcLayout  
 Aufgerufen, um das Layout des Rahmenfensters neu zu berechnen.  
  
```  
virtual void RecalcLayout(BOOL bNotify = TRUE);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `bNotify`  
 Bestimmt, ob das aktive in-Place-Element für das Rahmenfenster Benachrichtigung über die layoutänderung empfängt. Wenn `TRUE`, das Element ist, andernfalls benannten `FALSE`.  
  
### <a name="remarks"></a>Hinweise  
 Diese Methode überschreibt [CFrameWnd::RecalcLayout](../../mfc/reference/cframewnd-class.md#recalclayout).  
  
##  <a name="removepanefromdockmanager"></a>CMDIFrameWndEx::RemovePaneFromDockManager  
 Hebt die Registrierung eines Bereichs, und entfernt sie aus der Dockingstation-Manager.  
  
```  
void RemovePaneFromDockManager(
    CBasePane* pControlBar,  
    BOOL bDestroy,  
    BOOL bAdjustLayout,  
    BOOL bAutoHide,  
    CBasePane* pBarReplacement);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `pControlBar`  
 Ein Zeiger auf einen Bereich entfernt werden soll.  
  
 [in] `bDestroy`  
 `TRUE`Zerstören Sie Bereich entfernten. `FALSE`nicht es zerstört.  
  
 [in] `bAdjustLayout`  
 `TRUE`das Andocken Layout sofort anpassen. Wenn `FALSE`, die Anpassung erfolgt nur bei einem Ereignis Neuzeichnen aus anderen Gründen ausgelöst (der Benutzer die Fenstergröße, zieht der Hauptframe usw.).  
  
 [in] `bAutoHide`  
 `TRUE`im Bereich aus der Liste der Bereiche automatisch im Hintergrund zu entfernen. `FALSE`um den Bereich aus der Liste der regulären Bereiche zu entfernen.  
  
 [in] `pBarReplacement`  
 Ein Zeiger auf einen Bereich, der Bereich entfernten ersetzt.  
  
### <a name="remarks"></a>Hinweise  
 Sie müssen jeden Bereich mit dem docking-Manager zur Teilnahme an der andocklayout registrieren. Verwendung [CMDIFrameWndEx::AddPane](#addpane) oder [CMDIFrameWndEx::InsertPane](#insertpane) Bereiche zu registrieren.  
  
 Verwenden Sie diese Methode, wenn ein Bereich nicht mehr Teil des andocklayouts des Rahmenfensters ist.  
  
##  <a name="savemdistate"></a>CMDIFrameWndEx::SaveMDIState  
 Speichert das aktuelle Layout im Registerkartenformat MDI-Gruppen und die Liste der zuvor geöffneten Dokumente.  
  
```  
virtual BOOL SaveMDIState(LPCTSTR lpszProfileName);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `lpszProfileName`  
 Gibt den Namen des Profils an.  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn das Speichern erfolgreich war; `FALSE` Wenn Fehler beim Speichern.  
  
### <a name="remarks"></a>Hinweise  
 Zum Laden oder speichern Sie den Status der MDI-Registerkarten und Gruppen und die Liste der geöffneten Dokumente, führen Sie folgende Schritte aus:  
  
-   Rufen Sie `SaveMDIState` , wenn der Hauptframe wird geschlossen  
  
-   Rufen Sie [CMDIFrameWndEx::LoadMDIState](#loadmdistate) Wenn Hauptframe erstellt wird. Der empfohlene Speicherort für diesen Aufruf ist, bevor der Hauptframe zum ersten Mal angezeigt wird.  
  
-   Rufen Sie `CWinAppEx::EnableLoadWindowPlacement(FALSE);` vor`pMainFrame->LoadFrame (IDR_MAINFRAME);`  
  
-   Rufen Sie `CWinAppEx::ReloadWindowPlacement``(pMainFrame)` nach `LoadMDIState` Hauptframe an der Position angezeigt, die in der Registrierung gespeichert wurde.  
  
-   Überschreiben Sie `GetDocumentName` in der `CMDIChildWndEx`-abgeleitete Klasse, wenn Ihre Anwendung Dokumente angezeigt, die nicht als Dateien gespeichert werden. Die zurückgegebene Zeichenfolge wird als eine Dokument-ID in der Registrierung gespeichert. Weitere Informationen finden Sie unter [CMDIChildWndEx::GetDocumentName](../../mfc/reference/cmdichildwndex-class.md#getdocumentname).  
  
-   Überschreiben Sie [CMDIFrameWndEx::CreateDocumentWindow](#createdocumentwindow) Dokumente ordnungsgemäß zu erstellen, wenn sie aus der Registrierung geladen werden. Der Parameter `CreateDocumentWindow` ist eine Zeichenfolge, die `GetDocumentName` zuvor zurückgegeben.  
  
### <a name="example"></a>Beispiel  
 Das folgende Beispiel zeigt wie `SaveMDIState` werden in der [VisualStudioDemo-Beispiel: MFC-Anwendung für Visual Studio](../../visual-cpp-samples.md).  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo&#15;](../../mfc/codesnippet/cpp/cmdiframewndex-class_14.cpp)]  
  
##  <a name="setprintpreviewframe"></a>CMDIFrameWndEx::SetPrintPreviewFrame  
 Legt das Rahmenfenster Seitenansicht.  
  
```  
void SetPrintPreviewFrame(CFrameWnd* pWnd);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `pWnd`  
 Ein Zeiger auf ein Rahmenfenster Seitenansicht.  
  
### <a name="remarks"></a>Hinweise  
  
##  <a name="setuptoolbarmenu"></a>CMDIFrameWndEx::SetupToolbarMenu  
 Ändert ein Symbolleistenobjekt indem dummy Elemente durch benutzerdefinierte ersetzt.  
  
```  
void SetupToolbarMenu(
    CMenu& menu,  
    const UINT uiViewUserToolbarCmdFirst,  
    const UINT uiViewUserToolbarCmdLast);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `menu`  
 Ein Verweis auf eine [CMenu-Klasse](../../mfc/reference/cmenu-class.md) Objekt geändert werden.  
  
 [in] `uiViewUserToolbarCmdFirst`  
 Gibt den ersten benutzerdefinierten Befehl.  
  
 [in] `uiViewUserToolbarCmdLast`  
 Gibt den letzten benutzerdefinierten Befehl.  
  
##  <a name="showfullscreen"></a>CMDIFrameWndEx::ShowFullScreen  
 Wechselt den Hauptframe vom normalen Modus auf den Vollbildmodus.  
  
```  
void ShowFullScreen();
```  
  
### <a name="remarks"></a>Hinweise  
  
##  <a name="showpane"></a>CMDIFrameWndEx::ShowPane  
 Anzeigen oder ausblenden im angegebenen Bereich.  
  
```  
void ShowPane(
    CBasePane* pBar,  
    BOOL bShow,  
    BOOL bDelay,  
    BOOL bActivate);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `pBar`  
 Ein Zeiger auf den Bereich, um angezeigt oder ausgeblendet werden.  
  
 [in] `bShow`  
 `TRUE`um den Bereich anzuzeigen. `FALSE`um das Fenster auszublenden.  
  
 [in] `bDelay`  
 `TRUE`um die Berechnung des andocklayouts zu verzögern. `FALSE`das Andocken Layout sofort neu zu berechnen.  
  
 [in] `bActivate`  
 `TRUE`sollten als aktiv, um den Bereich anzuzeigen. `FALSE`um den Bereich als inaktiv angezeigt.  
  
### <a name="remarks"></a>Hinweise  
 Rufen Sie diese Methode zum ein- oder Ausblenden des Bereichs. Verwenden Sie keine `ShowWindow` für andockbare Bereiche.  
  
### <a name="example"></a>Beispiel  
 Das folgende Beispiel zeigt wie `ShowPane` werden in der [VisualStudioDemo-Beispiel: MFC-Anwendung für Visual Studio](../../visual-cpp-samples.md).  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo Nr.&16;](../../mfc/codesnippet/cpp/cmdiframewndex-class_15.cpp)]  
  
##  <a name="showwindowsdialog"></a>CMDIFrameWndEx::ShowWindowsDialog  
 Erstellt eine [CMFCWindowsManagerDialog](../../mfc/reference/cmfcwindowsmanagerdialog-class.md) Feld und öffnet sie.  
  
```  
void ShowWindowsDialog();
```  
  
### <a name="example"></a>Beispiel  
 Das folgende Beispiel zeigt wie `ShowWindowsDialog` werden in der [VisualStudioDemo-Beispiel: MFC-Anwendung für Visual Studio](../../visual-cpp-samples.md).  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo&18;](../../mfc/codesnippet/cpp/cmdiframewndex-class_16.cpp)]  
  
##  <a name="tabbeddocumenttocontrolbar"></a>CMDIFrameWndEx::TabbedDocumentToControlBar  
 Konvertiert das angegebene Dokument im Registerkartenformat an einen andockbaren Bereich.  
  
```  
virtual BOOL TabbedDocumentToControlBar(CMDIChildWndEx* pMDIChildWnd);
```  
  
### <a name="parameters"></a>Parameter  
 `pMDIChildWnd`  
 Ein Zeiger auf untergeordnete MDI-Fenster, das einen andockbaren Bereich enthält.  
  
### <a name="return-value"></a>Rückgabewert  
 `TRUE`Wenn die Methode erfolgreich war, `FALSE` bei einem Fehler.  
  
### <a name="remarks"></a>Hinweise  
 Verwenden Sie diese Methode, um ein Dokument im Registerkartenformat in einen andockbaren Bereich zu konvertieren. Das Dokument im Registerkartenformat erstellen mithilfe von [CMDIFrameWndEx::ControlBarToTabbedDocument](#controlbartotabbeddocument).  
  
### <a name="example"></a>Beispiel  
 Das folgende Beispiel zeigt wie `TabbedDocumentToControlBar` werden in der [VisualStudioDemo-Beispiel: MFC-Anwendung für Visual Studio](../../visual-cpp-samples.md).  
  
 [!code-cpp[NVC_MFC_VisualStudioDemo Nr.&19;](../../mfc/codesnippet/cpp/cmdiframewndex-class_17.cpp)]  
  
##  <a name="updatecaption"></a>CMDIFrameWndEx::UpdateCaption  
 Aufgerufen, um die Beschriftung des Fensters Frame zu aktualisieren.  
  
```  
void UpdateCaption();
```  
  
### <a name="remarks"></a>Hinweise  
  
##  <a name="updatemditabbedbarsicons"></a>CMDIFrameWndEx::UpdateMDITabbedBarsIcons  
 Wird das Symbol für jede MDI im Registerformat.  
  
```  
void UpdateMDITabbedBarsIcons();
```  
  
##  <a name="winhelp"></a>CMDIFrameWndEx::WinHelp  
 Wird vom Framework aufgerufen, um die WinHelp-Anwendung oder die Kontexthilfe zu initiieren.  
  
```  
virtual void WinHelp(
    DWORD dwData,  
    UINT nCmd = HELP_CONTEXT);
```  
  
### <a name="parameters"></a>Parameter  
 [in] `dwData`  
 Gibt die für den durch `nCmd`angegeben Typ der Hilfe erforderlichen Daten an.  
  
 [in] `nCmd`  
 Gibt den Typ der angeforderten Hilfe an. Eine Liste der möglichen Werte und deren Einfluss auf den `dwData` -Parameter finden Sie unter der [WinHelp-Funktion](http://msdn.microsoft.com/library/windows/desktop/bb762267) im Windows SDK.  
  
### <a name="remarks"></a>Hinweise  
 Diese Methode überschreibt [CWnd::WinHelp](../../mfc/reference/cwnd-class.md#winhelp).  
  
## <a name="see-also"></a>Siehe auch  
 [Hierarchiediagramm](../../mfc/hierarchy-chart.md)   
 [Klassen](../../mfc/reference/mfc-classes.md)   
 [CMDIFrameWnd](../../mfc/reference/cframewnd-class.md)   
 [CMDIChildWndEx-Klasse](../../mfc/reference/cmdichildwndex-class.md)

